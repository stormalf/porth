
//header assembly
MACRO common_header
"%define SYS_EXIT 60\n" putf
"%define SYS_READ 0\n" putf
"%define SYS_WRITE 1\n" putf
"%define SYS_OPEN 2\n" putf
"%define SYS_CLOSE 3\n" putf
"%define BUFFER_SIZE 2048\n" putf
"%define STDOUT 1\n" putf
"BITS 64\n" putf
"segment .text\n" putf
"_read_write:\n" putf
" ; read file into a buffer\n" putf
"  mov rax, SYS_READ\n" putf
"  mov rdi, [_fd]\n" putf
"  mov rsi, _file_buffer\n" putf
"  mov rdx, BUFFER_SIZE\n" putf
"  syscall\n" putf
"  ret\n" putf
"_open:\n" putf
"    mov rax, SYS_OPEN  ; sys_open\n" putf
"    mov rdi, [_file]   ; get file name address\n" putf
"    mov rsi, [_options] ; read only\n" putf
"    syscall\n" putf
"    ;add eax, '0'     ; load fd\n" putf
"    mov dword [_fd], eax  ; move _fd to buf\n" putf
"    ret\n" putf
"_close:\n" putf
"    mov rsi, _fd\n" putf
"    mov rdi, SYS_CLOSE\n" putf
"    mov rax, 0\n" putf
"    syscall\n" putf
"    ret\n" putf
"_write_buffer:\n" putf
"  ; write the buffer content to the file descriptor\n" putf
"  mov rdx, [_bufread] ; message length\n" putf
"  mov rax, SYS_WRITE ; system call number (sys_write)\n" putf
"  mov rdi, [_fd]; file descriptor\n" putf
"  mov rsi, _file_buffer\n" putf
"  syscall\n" putf
"  ret\n" putf
"; Input\n" putf
"; RAX = pointer to the int to convert\n" putf
"; RDI = address of the result\n" putf
"; R9 = number of digits\n" putf
"; Output:\n" putf
"; None\n" putf
"_int_to_string:\n" putf
"    xor r9, r9            ; initialize r9\n" putf
"    xor   rbx, rbx        ; clear the rbx, I will use as counter for stack pushes\n" putf
".push_chars:\n" putf
"    inc r9                ; increment the counter\n" putf
"    xor rdx, rdx          ; clear rdx\n" putf
"    mov rcx, 10           ; rcx is divisor, devide by 10\n" putf
"    div rcx               ; devide rdx by rcx, result in rax remainder in rdx\n" putf
"    add rdx, 0x30         ; add 0x30 to rdx convert int => ascii\n" putf
"    push rdx              ; push result to stack\n" putf
"    inc rbx               ; increment my stack push counter\n" putf
"    test rax, rax         ; is rax 0?\n" putf
"    jnz .push_chars       ; if rax not 0 repeat\n" putf
"\n" putf
".pop_chars:\n" putf
"    pop rax               ; pop result from stack into rax\n" putf
"    stosb                 ; store contents of rax in at the address of num which is in RDI\n" putf
"    dec rbx               ; decrement my stack push counter\n" putf
"    cmp rbx, 0            ; check if stack push counter is 0\n" putf
"    jg .pop_chars         ; not 0 repeat\n" putf
"    mov rax, 0x0\n" putf
"    stosb                 ; add null terminated character\n" putf
"    ret                   ; return to main\n" putf

ENDM

//header for assembly without libc!
MACRO header2 
"print:\n" putf
"    mov r9, -3689348814741910323\n" putf
"    sub rsp, 40\n" putf
"    mov BYTE [rsp+31], 10\n" putf
"    lea rcx, [rsp+30]\n" putf
".L2:\n" putf
"    mov rax, rdi\n" putf
"    lea r8, [rsp+32]\n" putf
"    mul r9\n" putf
"    mov rax, rdi\n" putf
"    sub r8, rcx\n" putf
"    shr rdx, 3\n" putf
"    lea rsi, [rdx+rdx*4]\n" putf
"    add rsi, rsi\n" putf
"    sub rax, rsi\n" putf
"    add eax, 48\n" putf
"    mov BYTE [rcx], al\n" putf
"    mov rax, rdi\n" putf
"    mov rdi, rdx\n" putf
"    mov rdx, rcx\n" putf
"    sub rcx, 1\n" putf
"    cmp rax, 9\n" putf
"    ja .L2\n" putf
"    lea rax, [rsp+32]\n" putf
"    mov edi, 1\n" putf
"    sub rdx, rax\n" putf
"    xor eax, eax\n" putf
"    lea rsi, [rsp+32+rdx]\n" putf
"    mov rdx, r8\n" putf
"    mov rax, 1\n" putf
"    syscall\n" putf
"    ;call write\n" putf
"    add rsp, 40\n" putf
"    ret\n" putf
"print_char:\n" putf
"    push   rbp\n" putf
"    mov    rbp, rsp\n" putf
"    sub    rsp, 16\n" putf
"    mov    rax, rdi\n" putf
"    mov    [rbp - 4], al\n" putf
"    lea    rsi, [rbp - 4]\n" putf
"    mov    rdx, 1\n" putf
"    mov    rdi, 1\n" putf
"    mov    rax, 1\n" putf
"    syscall\n" putf
"    add rsp, 16\n" putf
"    pop    rbp\n" putf
"    ret\n" putf
"global _start\n" putf
"_start:\n" putf
ENDM

//footer assembly
MACRO footer 
"mov rax, SYS_EXIT\n" putf
"mov rdi, 0\n" putf
"syscall\n" putf
ENDM

//data assembly
MACRO data
"section .data \n" putf
"_format db  '%lld', 10, 0\n" putf
"_format2 db '%s', 10, 0\n" putf
"_char db  '%c', 0\n" putf
"_negative db '-', 0\n" putf
"_security  dq  100000000\n" putf
ENDM


//bss assembly
MACRO bss
"section .bss    ; uninitialized data section\n" putf
"_file RESQ 1\n" putf
"_options RESQ 1\n" putf
"_fd RESQ 1\n" putf
"_file_buffer resb BUFFER_SIZE\n" putf
"_bufread RESQ 1\n" putf
"_mem: resb 640000\n" putf 
ENDM

MACRO generate_op_add
        "; add \n" putf
        "pop    rax \n" putf
        "pop    rcx \n" putf
        "add    rax, rcx \n" putf
        "push    rax \n" putf
ENDM

MACRO generate_op_dump
            "pop rdi \n" putf
            "call print\n" putf
ENDM
