INCLUDE "include/std.porth"
VAR fw u8 

MACRO putf
fw write
ENDM

MACRO common_header
"%define SYS_EXIT 60\n" putf
"%define SYS_READ 0\n" putf
"%define SYS_WRITE 1\n" putf
"%define SYS_OPEN 2\n" putf
"%define SYS_CLOSE 3\n" putf
"%define BUFFER_SIZE 2048\n" putf
"%define STDOUT 1\n" putf
"BITS 64\n" putf
"segment .text\n" putf
"_read_write:\n" putf
" ; read file into a buffer\n" putf
"  mov rax, SYS_READ\n" putf
"  mov rdi, [_fd]\n" putf
"  mov rsi, _file_buffer\n" putf
"  mov rdx, BUFFER_SIZE\n" putf
"  syscall\n" putf
"  ret\n" putf
"_open:\n" putf
"    mov rax, SYS_OPEN  ; sys_open\n" putf
"    mov rdi, [_file]   ; get file name address\n" putf
"    mov rsi, [_options] ; read only\n" putf
"    syscall\n" putf
"    ;add eax, '0'     ; load fd\n" putf
"    mov dword [_fd], eax  ; move _fd to buf\n" putf
"    ret\n" putf
"_close:\n" putf
"    mov rsi, _fd\n" putf
"    mov rdi, SYS_CLOSE\n" putf
"    mov rax, 0\n" putf
"    syscall\n" putf
"    ret\n" putf
"_write_buffer:\n" putf
"  ; write the buffer content to the file descriptor\n" putf
"  mov rdx, [_bufread] ; message length\n" putf
"  mov rax, SYS_WRITE ; system call number (sys_write)\n" putf
"  mov rdi, [_fd]; file descriptor\n" putf
"  mov rsi, _file_buffer\n" putf
"  syscall\n" putf
"  ret\n" putf
ENDM

MACRO header2 
"print:\n" putf
"    mov r9, -3689348814741910323\n" putf
"    sub rsp, 40\n" putf
"    mov BYTE [rsp+31], 10\n" putf
"    lea rcx, [rsp+30]\n" putf
".L2:\n" putf
"    mov rax, rdi\n" putf
"    lea r8, [rsp+32]\n" putf
"    mul r9\n" putf
"    mov rax, rdi\n" putf
"    sub r8, rcx\n" putf
"    shr rdx, 3\n" putf
"    lea rsi, [rdx+rdx*4]\n" putf
"    add rsi, rsi\n" putf
"    sub rax, rsi\n" putf
"    add eax, 48\n" putf
"    mov BYTE [rcx], al\n" putf
"    mov rax, rdi\n" putf
"    mov rdi, rdx\n" putf
"    mov rdx, rcx\n" putf
"    sub rcx, 1\n" putf
"    cmp rax, 9\n" putf
"    ja .L2\n" putf
"    lea rax, [rsp+32]\n" putf
"    mov edi, 1\n" putf
"    sub rdx, rax\n" putf
"    xor eax, eax\n" putf
"    lea rsi, [rsp+32+rdx]\n" putf
"    mov rdx, r8\n" putf
"    mov rax, 1\n" putf
"    syscall\n" putf
"    ;call write\n" putf
"    add rsp, 40\n" putf
"    ret\n" putf
"print_char:\n" putf
"    push   rbp\n" putf
"    mov    rbp, rsp\n" putf
"    sub    rsp, 16\n" putf
"    mov    rax, rdi\n" putf
"    mov    [rbp - 4], al\n" putf
"    lea    rsi, [rbp - 4]\n" putf
"    mov    rdx, 1\n" putf
"    mov    rdi, 1\n" putf
"    mov    rax, 1\n" putf
"    syscall\n" putf
"    add rsp, 16\n" putf
"    pop    rbp\n" putf
"    ret\n" putf
"global _start\n" putf
"_start:\n" putf
ENDM

MACRO footer 
"mov rax, SYS_EXIT\n" putf
"mov rdi, 0\n" putf
"syscall\n" putf
ENDM

MACRO data
"section .data \n" putf
"_format db  '%lld', 10, 0\n" putf
"_format2 db '%s', 10, 0\n" putf
"_char db  '%c', 0\n" putf
"_negative db '-', 0\n" putf
"_security  dq  100000000\n" putf
ENDM

//op macros
MACRO OP_PUSH_INT 0 ENDM
MACRO OP_PLUS 1 ENDM
MACRO OP_PRINT 2 ENDM

//memory macros
MACRO PUTD_BUFFER_CAP 32 ENDM 
MACRO putd_buffer MEM ENDM
MACRO MEM_CAPACITY 640000 ENDM

MACRO putd
  DUP 0 = IF
    "0" putf
  ELSE
    putd_buffer PUTD_BUFFER_CAP +
    WHILE OVER 0 > DO
      1 - DUP ROT 
      10 DIVMOD
      ROT SWAP '0' + @ SWAP
    END
    DUP    
    putd_buffer PUTD_BUFFER_CAP + SWAP - SWAP putf
  END
  //DROP will be done in the main loop to drop memory address
ENDM

MACRO ops-count 
putd_buffer PUTD_BUFFER_CAP +   
ENDM

MACRO ops 
ops-count 8 + 
ENDM

MACRO sizeof(Op) 
16 
ENDM

//0 34  (0*16) + 8) + index   
MACRO push-op 
ops-count $64 sizeof(Op) MUL ops + 
DUP 8 + ROT @64 SWAP
@64  
ops-count inc64 
ENDM

MACRO dump-ops
0 WHILE DUP ops-count $64 < DO
DUP sizeof(Op) MUL ops + 
"Type:       " puts DUP $64 .
"Operand:    " puts 8 + $64 .
"----------\n" puts
1 +
END
ENDM


MACRO bss
"section .bss    ; uninitialized data section\n" putf
"_file RESQ 1\n" putf
"_options RESQ 1\n" putf
"_fd RESQ 1\n" putf
"_file_buffer resb BUFFER_SIZE\n" putf
"_bufread RESQ 1\n" putf
"_mem: resb 640000\n" putf //MEM_CAPACITY putd "\n" putf
ENDM

//struct OP {
//    type: u64,
//    operand: u64
//}

MACRO simulate-op
"TODO: simulation not implemented yet\n" putf 1 EXIT
ENDM


MACRO compile-ops 
"./bin/hello2.asm" OPENW !fw
common_header
header2
0 WHILE DUP ops-count $64 < DO
//ptr type
DUP sizeof(Op) MUL ops + 
DUP $64 OP_PUSH_INT = IF
    "; push \n" putf   
    "mov rax, " putf 8 + $64 putd "\n" putf       
    "push rax\n" putf
    //DROP
ELSE
    DUP $64 OP_PLUS = IF
        "; add \n" putf
        "pop    rax \n" putf
        "pop    rcx \n" putf
        "add    rax, rcx \n" putf
        "push    rax \n" putf
        //DROP
    ELSE
        DUP $64 OP_PRINT = IF
            "pop rdi \n" putf
            "call print\n" putf
      //DROP
        ELSE
            "unreachable\n" puts 1 EXIT
        END
        END
        END
DROP //drop memory address!
1 +
END
footer
data
bss
fw CLOSE
ENDM 

OP_PUSH_INT 35 push-op
OP_PUSH_INT 36 push-op
OP_PLUS 0 push-op
OP_PRINT 0 push-op
OP_PUSH_INT 25 push-op
OP_PUSH_INT 26 push-op
OP_PLUS 0 push-op
OP_PRINT 0 push-op

//dump-ops
compile-ops

DROP
